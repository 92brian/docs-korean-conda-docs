# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Anaconda, Inc.
# This file is distributed under the same license as the Conda package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Conda  \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-18 12:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:5
msgid "Defining metadata (meta.yaml)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:12
msgid ""
"All the metadata in the conda build recipe is specified in the "
"``meta.yaml`` file, as in this simple example:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:17
msgid ""
"All sections are optional except for ``package/name`` and "
"``package/version``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:20
msgid ""
"Headers must appear only once. If they appear multiple times, only the "
"last is remembered. For example, the ``package:`` header should appear "
"only once in the file."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:26
msgid "Package section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:28
msgid "Specifies package information."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:31
msgid "Package name"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:33
msgid "The lower case name of the package. It may contain \"-\", but no spaces."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:42
msgid "Package version"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:44
msgid ""
"The version number of the package. Use the `PEP 440 "
"<https://www.python.org/dev/peps/pep-0440/>`_ verlib conventions. Cannot "
"contain \"-\". YAML interprets version numbers such as 1.0 as floats, "
"meaning that 0.10 will be the same as 0.1. To avoid this, put the version"
" number in quotes so that it is interpreted as a string."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:55
msgid ""
"NOTE: Post-build versioning: In some cases, you may not know the version,"
" build number or build string of the package until after it is built. In "
"these cases, you can perform :ref:`jinja-templates` or utilize :ref:`git-"
"env` and :ref:`inherited-env-vars`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:63
msgid "Source section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:65
msgid ""
"Specifies where the source code of the package is coming from. The source"
" may come from a tarball file, git, hg or svn. It may be a local path, "
"and it may contain patches."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:71
msgid "Source from tarball or zip archive"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:81
msgid ""
"If an extracted archive contains only one folder at its top level, its "
"contents will be moved one level up, so that the extracted package "
"contents sit in the root of the work folder."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:86
msgid "Source from git"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:88
msgid "The git_url can also be a relative path to the recipe directory."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:98
msgid "Source from hg"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:108
msgid "Source from svn"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:119
msgid "Source from a local path"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:121
msgid ""
"If the path is relative, it is taken relative to the recipe directory. "
"The source is copied to the work directory before building."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:130
msgid ""
"If the local path is a git or svn repository, you get the corresponding "
"environment variables defined in your build environment. The only "
"practical difference between git_url or hg_url and path as source "
"arguments is that git_url and hg_url would be clones of a repository, "
"while path would be a copy of the repository. Using path allows you to "
"build packages with unstaged and uncommitted changes in the working "
"directory. git_url can build only up to the latest commit."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:141
msgid "Patches"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:143
msgid "Patches may optionally be applied to the source."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:152
msgid "Conda build automatically determines the patch strip level."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:155
msgid "Destination path"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:157
msgid ""
"Within conda-build's work directory, you may specify a particular folder "
"to place source into. This feature is new in conda-build 3.0. Conda-build"
" will always drop you into the same folder (build folder/work), but it's "
"up to you whether you want your source extracted into that folder, or "
"nested deeper. This feature is particularly useful when dealing with "
"multiple sources, but can apply to recipes with single sources as well."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:171
msgid "Filename"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:173
msgid ""
"The filename key is ``fn``. It was formerly required with URL source "
"types. It is not required now."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:175
msgid ""
"If the ``fn`` key is provided, the file is saved on disk with that name. "
"If the ``fn`` key is not provided, the file is saved on disk with a name "
"matching the last part of the URL."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:177
msgid ""
"For example, ``http://www.something.com/myfile.zip`` has an implicit "
"filename of ``myfile.zip``. Users may change this by manually specifying "
"``fn``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:186
msgid "Source from multiple sources"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:188
msgid ""
"Some software is most easily built by aggregating several pieces. For "
"this, conda-build 3.0 has added support for arbitrarily specifying many "
"sources."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:191
msgid ""
"The syntax is a list of source dictionaries. Each member of this list "
"follows the same rules as the single source for earlier conda-build "
"versions (listed above). All features for each member are supported."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:195
msgid "Example:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:207
msgid ""
"Here, the two URL tarballs will go into one folder, and the git repo is "
"checked out into its own space. Git will not clone into a non-empty "
"folder."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:210
msgid "Note: Dashes denote list items in YAML syntax."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:216
msgid "Build section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:218
msgid "Specifies build information."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:220
msgid ""
"Each field that expects a path can also handle a glob pattern. The "
"matching is performed from the top of the build environment, so to match "
"files inside your project you can use a pattern similar to the following "
"one: \"\\*\\*/myproject/\\*\\*/\\*.txt\". This pattern will match any "
".txt file found in your project."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:226
msgid ""
"NOTE: The quotation marks (\"\") are required for patterns that start "
"with a \\*."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:228
msgid "Recursive globbing using \\*\\* is supported only in conda-build >= 3.0."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:231
msgid "Build number and string"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:233
msgid ""
"The build number should be incremented for new builds of the same "
"version. The number defaults to ``0``. The build string cannot contain "
"\"-\". The string defaults to the default conda build string plus the "
"build number."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:246
msgid "Python entry points"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:248
msgid ""
"The following example creates a Python entry point named \"bsdiff4\" that"
" calls ``bsdiff4.cli.main_bsdiff4()``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:259
msgid "Python.app"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:261
msgid ""
"If osx_is_app is set, entry points use ``python.app`` instead of Python "
"in macOS. The default is ``False``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:271
msgid "Features"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:273
msgid ""
"Defines what features a package has. For more information, see "
":doc:`features`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:284
msgid "Track features"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:286
msgid ""
"To enable a feature, install a package that tracks that feature. A "
"package can have a feature, track that feature, or both, or neither. "
"Usually it is best for the package that tracks a feature to be a "
"metapackage that does not have the feature. For more information, see "
":doc:`features`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:300
msgid "Preserve Python egg directory"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:302
msgid ""
"This is needed for some packages that use features specific to "
"setuptools. The default is ``False``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:312
msgid "Skip compiling some .py files into .pyc files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:314
msgid ""
"Some packages ship ``.py`` files that cannot be compiled, such as those "
"that contain templates. Some packages also ship ``.py`` files that should"
" not be compiled yet, because the Python interpreter that will be used is"
" not known at build time. In these cases, conda build can skip attempting"
" to compile these files. The patterns used in this section do not need "
"the \\*\\* to handle recursive paths."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:333
msgid "No link"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:335
msgid ""
"A list of globs for files that should always be copied and never soft "
"linked or hard linked."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:345
msgid "Script"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:347
msgid ""
"Used instead of ``build.sh`` or ``bld.bat``. For short build scripts, "
"this can be more convenient. You may need to use :ref:`selectors "
"<preprocess-selectors>` to use different scripts for different platforms."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:358
msgid "RPATHs"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:360
msgid ""
"Set which RPATHs are used when making executables relocatable on Linux. "
"This is a Linux feature that is ignored on other systems. The default is "
"``lib/``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:373
msgid "Force files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:375
msgid ""
"Force files to always be included, even if they are already in the "
"environment from the build dependencies. This may be needed, for example,"
" to create a recipe for conda itself."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:388
msgid "Relocation"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:390
msgid ""
"Advanced features. You can use the following 4 keys to control "
"relocatability files from the build environment to the installation "
"environment:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:394
msgid "binary_relocation."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:395
msgid "has_prefix_files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:396
msgid "binary_has_prefix_files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:397
msgid "ignore_prefix_files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:399
msgid "For more information, see :doc:`make-relocatable`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:403
msgid "Binary relocation"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:405
msgid ""
"Whether binary files should be made relocatable using install_name_tool "
"on macOS or patchelf on Linux. The default is ``True``. It also accepts "
"``False``, which indicates no relocation for any files, or a list of "
"files, which indicates relocation only for listed files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:420
msgid "Detect binary files with prefix"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:422
msgid ""
"Binary files may contain the build prefix and need it replaced with the "
"install prefix at installation time. Conda can automatically identify and"
" register such files. The default is ``True``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:427
msgid ""
"NOTE: The default changed from ``False`` to ``True`` in conda build 2.0. "
"Setting this to ``False`` means that binary relocation---RPATH---"
"replacement will still be done, but hard-coded prefixes in binaries will "
"not be replaced. Prefixes in text files will still be replaced."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:438
msgid ""
"Windows handles binary prefix replacement very differently than Unix-like"
" systems such as macOS and Linux. At this time, we are unaware of any "
"executable or library that uses hardcoded embedded paths for locating "
"other libraries or program data on Windows. Instead, Windows follows `DLL"
" search path rules <https://msdn.microsoft.com/en-"
"us/library/7d83bc18.aspx>`_ or more natively supports relocatability "
"using relative paths. Because of this, conda ignores most prefixes. "
"However, pip creates executables for Python entry points that do use "
"embedded paths on Windows. Conda build thus detects prefixes in all files"
" and records them by default. If you are getting errors about path length"
" on Windows, you should try to disable detect_binary_files_with_prefix. "
"Newer versions of Conda, such as recent 4.2.x series releases and up, "
"should have no problems here, but earlier versions of conda do "
"erroneously try to apply any binary prefix replacement."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:459
msgid "Binary has prefix files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:461
msgid ""
"By default, conda build tries to detect prefixes in all files. You may "
"also elect to specify files with binary prefixes individually. This "
"allows you to specify the type of file as binary, when it may be "
"incorrectly detected as text for some reason. Binary files are those "
"containing NULL bytes."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:476
msgid "Text files with prefix files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:478
msgid ""
"Text files---files containing no NULL bytes---may contain the build "
"prefix and need it replaced with the install prefix at installation time."
" Conda will automatically register such files. Binary files that contain "
"the build prefix are generally handled differently---see :ref:`bin-"
"prefix`---but there may be cases where such a binary file needs to be "
"treated as an ordinary text file, in which case they need to be "
"identified."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:495
msgid "Ignore prefix files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:497
msgid ""
"Used to exclude some or all of the files in the build recipe from the "
"list of files that have the build prefix replaced with the install "
"prefix."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:501
msgid "To ignore all files in the build recipe, use:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:508
msgid "To specify individual filenames, use:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:516
msgid ""
"This setting is independent of RPATH replacement. Use the :ref:`detect-"
"bin` setting to control that behavior."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:521
msgid "Skipping builds"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:523
msgid ""
"Specifies whether conda build should skip the build of this recipe. "
"Particularly useful for defining recipes that are platform specific. The "
"default is ``False``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:534
msgid "Architecture independent packages"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:536
msgid ""
"Allows you to specify \"no architecture\" when building a package, thus "
"making it compatible with all platforms and architectures. Noarch "
"packages can be installed on any platform."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:540
msgid ""
"Starting with conda-build 2.1, and conda 4.3, there is a new syntax that "
"supports different languages. Assigning the noarch key as ``generic`` "
"tells conda to not try any manipulation of the contents."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:549
msgid ""
"``noarch: generic`` is most useful for packages such as static javascript"
" assets and source archives. For pure Python packages that can run on any"
" Python version, you can use the ``noarch: python`` value instead:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:558
msgid ""
"The legacy syntax for ``noarch_python`` is still valid, and should be "
"used when you need to be certain that your package will be installable "
"where conda 4.3 is not yet available. All other forms of noarch packages "
"require conda >=4.3 to install."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:570
msgid ""
"At the time of this writing, ``noarch`` packages should not make use of "
"`preprocess-selectors`_: ``noarch`` packages are built with the "
"directives which evaluate to ``True`` in the platform it was built, which"
" probably will result in incorrect/incomplete installation in other "
"platforms."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:576
msgid "Include build recipe"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:578
msgid ""
"The full conda build recipe and rendered ``meta.yaml`` file is included "
"in the :ref:`package_metadata` by default. You can disable this with:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:589
msgid "Use environment variables"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:591
msgid ""
"Normally the build script in ``build.sh`` or ``bld.bat`` does not pass "
"through environment variables from the command line. Only environment "
"variables documented in :ref:`env-vars` are seen by the build script. To "
"\"white-list\" environment variables that should be passed through to the"
" build script:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:604
msgid ""
"If a listed environment variable is missing from the environment seen by "
"the conda build process itself, a UserWarning is emitted during the build"
" process and the variable remains undefined."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:609
msgid ""
"NOTE: Inheriting environment variables can make it difficult for others "
"to reproduce binaries from source with your recipe. Use this feature with"
" caution or avoid it."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:613
msgid ""
"NOTE: If you split your build and test phases with ``--no-test`` and "
"``--test``, you need to ensure that the environment variables present at "
"build time and test time match. If you do not, the package hashes may use"
" different values, and your package may not be testable, because the "
"hashes will differ."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:622
msgid "Export runtime requirements"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:624
msgid ""
"Some build or host :ref:`requirements` will impose a runtime requirement."
" Most commonly this is true for shared libraries (e.g. libpng), which are"
" required for linking at build time, and for resolving the link at run "
"time. With ``run_exports`` (new in conda-build 3) such a runtime "
"requirement can be implicitly added by host requirements (e.g. libpng "
"exports libpng), and with ``run_exports/strong`` even by build "
"requirements (e.g. gcc exports libgcc)."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:638
msgid ""
"Here, because no specific kind of run_exports is specified, libpng's "
"run_exports are considered \"weak.\" This means they will only apply when"
" libpng is in the host section, when they will add their export to the "
"run section.  If libpng were listed in the build section, the run_exports"
" would not apply to the run section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:651
msgid ""
"Strong run_exports are used for things like runtimes, where the same "
"runtime needs to be present in the host and the run environment, and "
"exactly which runtime that should be is determined by what's present in "
"the build section. This mechanism is how we line up appropriate software "
"on windows, where we must match MSVC versions used across all of the "
"shared libraries in an environment."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:670
msgid ""
"You can express version constraints directly, or use any of the jinja2 "
"helper functions listed at :ref:`extra_jinja2`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:673
msgid ""
"For example, you may use :ref:`pinning_expressions` to obtain flexible "
"version pinning relative to versions present at build time:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:682
msgid ""
"With this example, if libpng were version 1.6.34, this pinning expression"
" would evaluate to ``>=1.6.34,<1.7``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:685
msgid ""
"Note that ``run_exports`` can be specified both in the build section, and"
" on a per-output basis for split packages."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:688
msgid ""
"``run_exports`` only affects directly named dependencies. For example, if"
" you have a metapackage that includes a compiler that lists "
"``run_exports``, you also need to define ``run_exports`` in the "
"metapackage so that it takes effect when people install your metapackage."
"  This is important, because if ``run_exports`` affected transitive "
"dependencies, you would see many added dependencies to shared libraries "
"where they are not actually direct dependencies. For example, Python uses"
" bzip2, which can use ``run_exports`` to make sure that people use a "
"compatible build of bzip2. If people list python as a build time "
"dependency, bzip2 should only be imposed for python itself, and should "
"not be automatically imposed as a runtime dependency for the thing using "
"python."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:700
msgid ""
"The potential downside of this feature is that it takes some control over"
" constraints away from downstream users. If an upstream package has a "
"problematic run_exports constraint, you can ignore it in your recipe by "
"listing the upstream package name in the ``build/ignore_run_exports`` "
"section:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:715
msgid "Requirements section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:717
msgid ""
"Specifies the build and runtime requirements. Dependencies of these "
"requirements are included automatically."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:720
msgid ""
"Versions for requirements must follow the conda match specification. See "
":ref:`build-version-spec` ."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:725
msgid "Build"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:727
msgid ""
"Tools required to build the package. These packages are run on the build "
"system and include things such as revision control systems (git, svn) "
"make tools (GNU make, Autotool, CMake) and compilers (real cross, pseudo-"
"cross, or native when not cross-compiling) and any source pre-processors."
" Packages which provide \"sysroot\" files, like the ``CDT`` packages (see"
" below) also belong in the build section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:744
msgid "Host"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:746
msgid ""
"This section was added in conda-build 3.0. It represents packages that "
"need to be specific to the target platform when the target platform is "
"not necessarily the same as the native build platform. For example, in "
"order for a recipe to \"cross-capable\", shared libraries requirements "
"must be listed in the host section, rather than the build section, so "
"that the shared libraries that get linked are ones for the target "
"platform, rather than the native build platform. You should also include "
"the base interpreter for packages that need one. In other words, a Python"
" package would list ``python`` here and an R package would list ``mro-"
"base`` or ``r-base``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:765
msgid ""
"Note: when both build and host sections are defined, the build section "
"can be thought of as \"build tools\" - things that run on the native "
"platform, but output results for the target platform. For example, a "
"cross-compiler that runs on linux-64, but targets linux-armv7."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:770
msgid ""
"The PREFIX environment variable points to the host prefix.  With respect "
"to activation during builds, both the host and build environments are "
"activated. The build prefix is activated before the host prefix, so that "
"the host prefix has priority over the build prefix. Executables that "
"don't exist in the host prefix should be found in the build prefix."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:776
msgid ""
"As of conda-build 3.1.4, the build and host prefixes are always separate "
"when both are defined, or when ``{{ compiler() }}`` jinja2 functions are "
"used. The only time that build and host are merged is when the host "
"section is absent, and no ``{{ compiler() }}`` jinja2 functions are used "
"in meta.yaml. Because these are separate, you may see some build failures"
" when migrating your recipes. For example, let's say you have a recipe to"
" build a python extension. If you add the compiler jinja2 functions to "
"the build section, but you do not move your python dependency from the "
"build section to the host section, your recipe will fail. It will fail "
"because the host environment is where new files are detected, but because"
" you have python only in the build environment, your extension will be "
"installed into the build environment. No files will be detected. Also, "
"variables such as PYTHON will not be defined when python is not installed"
" into the host environment."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:790
msgid ""
"On Linux, using the compiler packages provided by Anaconda Inc. in the "
"``defaults`` meta-channel you can prevent your build system leaking into "
"the built software by using our ``CDT`` (Core Dependency Tree) packages "
"for any \"system\" dependencies. These packages are repackaged libraries "
"and headers from CentOS6 and are unpacked into the sysroot of our pseudo-"
"cross compilers and are found by them automatically."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:796
msgid ""
"Note that what qualifies as a \"system\" dependency is a matter of "
"opinion. The Anaconda Distribution chose not to provide X11 or GL "
"packages, so we use CDT packages for X11. Conda-forge chose to provide "
"X11 and GL packages."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:800
msgid ""
"On macOS, you can use the equivalent compiler packages in conjunction "
"with the standard MACOSX_DEPLOYMENT_TARGET environment variable and set "
"the CONDA_BUILD_SYSROOT environment variable. This will specify a folder "
"containing a macOS SDK. This achieves backwards compatability while still"
" providing access to C++14 and C++1z."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:805
msgid ""
"**TL;DR**: If you use the new ``{{ compiler() }}`` jinja2 to utilize our "
"new compilers, you also must move anything that is not strictly a build "
"tool into your host dependencies. This includes python, python libraries,"
" and any shared libraries that you need to link against in your build. "
"Examples of build tools include any {{ compiler() }}, make, autoconf, "
"perl (for running scripts, not installing perl software), python (for "
"running scripts, not for installing software)."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:814
msgid "Run"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:816
msgid ""
"Packages required to run the package. These are the dependencies that are"
" installed automatically whenever the package is installed. Package names"
" should follow the :ref:`build-version-spec`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:829
msgid ""
"To build a recipe against different versions of NumPy and ensure that "
"each version is part of the package dependencies, list ``numpy x.x`` as a"
" requirement in ``meta.yaml`` and use ``conda-build`` with a NumPy "
"version option such as ``--numpy 1.7``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:835
msgid ""
"The line in the ``meta.yaml`` file should literally say ``numpy x.x`` and"
" should not have any numbers. If the ``meta.yaml`` file uses ``numpy "
"x.x``, it is required to use the ``--numpy`` option with ``conda-build``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:847
msgid ""
"**NOTE**: Instead of manually specifying run requirements, since conda-"
"build 3 you can augment the packages used in your build and host sections"
" with :ref:`run_exports <run_exports>` which are then automatically added"
" to the run requirements for you."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:855
msgid "Test section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:857
msgid ""
"If this section exists or if there is a ``run_test.[py,pl,sh,bat]`` file "
"in the recipe, the package is installed into a test environment after the"
" build is finished, and the tests are run there."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:863
msgid "Test files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:865
msgid ""
"Test files that are copied from the recipe into the temporary test "
"directory and are needed during testing."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:876
msgid "Source files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:878
msgid ""
"Test files that are copied from the source work directory into the "
"temporary test directory and are needed during testing."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:889
msgid "This capability was added in conda build 2.0."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:893
msgid "Test requirements"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:895
msgid ""
"In addition to the runtime requirements, you can specify requirements "
"needed during testing. The runtime requirements that you specified in the"
" \"run\" section described above are automatically included during "
"testing."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:907
msgid "Test commands"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:909
msgid "Commands that are run as part of the test."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:920
msgid "Python imports"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:922
msgid ""
"List of Python modules or packages that will be imported in the test "
"environment."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:931
msgid "This would be equivalent to having a ``run_test.py`` with the following:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:940
msgid "Run test script"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:942
msgid ""
"The script ``run_test.sh``---or ``.bat``, ``.py`` or ``.pl``---is run "
"automatically if it is part of the recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:945
msgid ""
"NOTE: Python .py and Perl .pl scripts are valid only as part of Python "
"and Perl packages, respectively."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:952
msgid "Outputs section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:954
msgid ""
"Explicitly specifies packaging steps. This section supports multiple "
"outputs, as well as different package output types. The format is a list "
"of mappings. Build strings for subpackages are determined by their "
"runtime dependencies. This support was added in conda build 2.1.0."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:969
msgid ""
"NOTE: If any output is specified in the outputs section, the default "
"packaging behavior of conda build is bypassed. In other words, if any "
"subpackage is specified, then you do not get the normal top-level build "
"for this recipe without explicitly defining a subpackage for it. This is "
"an alternative to the existing behavior, not an addition to it. For more "
"information, see :ref:`implicit_metapackages`. Each output may have its "
"own version and requirements. Additionally, subpackages may impose "
"downstream pinning similarly to :ref:`Pin downstream <run_exports>` to "
"help keep your packages aligned."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:981
msgid "Specifying files to include in output"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:983
msgid "You can specify files to be included in the package in either of two ways:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:986
msgid "Explicit file lists."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:988
msgid "Scripts that move files into the build prefix."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:990
msgid ""
"Explicit file lists are relative paths from the root of the build prefix."
" Explicit file lists support glob expressions. Directory names are also "
"supported, and they recursively include contents."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1005
msgid ""
"Scripts that create or move files into the build prefix can be any kind "
"of script. Known script types need only specify the script name. "
"Currently the list of recognized extensions is py, bat, ps1 and sh."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1016
msgid ""
"The interpreter command must be specified if the file extension is not "
"recognized."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1026
msgid ""
"For scripts that move or create files, a fresh copy of the working "
"directory is provided at the start of each script execution. This ensures"
" that results between scripts are independent of one another."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1031
msgid ""
"NOTE: For either the file list or the script approach, having more than 1"
" package contain a given file is not explicitly forbidden, but may "
"prevent installation of both packages simultaneously. Conda disallows "
"this condition, because it creates ambiguous runtime conditions."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1039
msgid "Subpackage requirements"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1041
msgid ""
"Like a top level recipe, a subpackage may have zero or more dependencies "
"listed as build requirements and zero or more dependencies listed as run "
"requirements."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1044
msgid ""
"The dependencies listed as subpackage build requirements are available "
"only during the packaging phase of that subpackage."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1047
msgid ""
"A subpackage does not automatically inherit any dependencies from its top"
" level recipe, so any build or run requirements needed by the subpackage "
"must be explicitly specified."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1063
msgid ""
"It is also possible for a subpackage requirements section to have a list "
"of dependencies but no build section or run section. This is the same as "
"having a build section with this dependency list and a run section with "
"the same dependency list."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1075
msgid ""
"You can also impose runtime dependencies whenever a given (sub)package is"
" installed as a build dependency. For example, if we had an overarching "
"\"compilers\" package, and within that, had ``gcc`` and ``libgcc`` "
"outputs, we could force recipes that use gcc to include a matching libgcc"
" runtime requirement:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1089
msgid "See the :ref:`run_exports` section for additional information."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1091
msgid ""
"Note: Variant expressions are very powerful here. You can express the "
"version requirement in the run_exports entry as a jinja function to "
"insert values based on the actual version of libgcc produced by the "
"recipe. Read more about them at :ref:`referencing_subpackages`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1099
msgid "Implicit metapackages"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1101
msgid ""
"When viewing the top-level package as a collection of smaller "
"subpackages, it may be convenient to define the top-level package as a "
"composition of several subpackages. If you do this and you do not define "
"a subpackage name that matches the top-level package/name, conda build "
"creates a metapackage for you. This metapackage has runtime requirements "
"drawn from its dependency subpackages, for the sake of accurate build "
"strings."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1109
msgid ""
"EXAMPLE: In this example, a metapackage for ``subpackage-example`` will "
"be created. It will have runtime dependencies on ``subpackage1``, "
"``subpackage2``, ``some-dep`` and ``some-other-dep``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1138
msgid "Subpackage tests"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1140
msgid ""
"You can test subpackages independently of the top-level package. "
"Independent test script files for each separate package are specified "
"under the subpackage's test section. These files support the same formats"
" as the top-level ``run_test.*`` scripts, which are .py, .pl, .bat and "
".sh. These may be extended to support other script types in the future."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1155
msgid ""
"By default, the ``run_test.*`` scripts apply only to the top-level "
"package. To apply them also to subpackages, list them explicitly in the "
"script section:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1167
msgid ""
"Test requirements for subpackages are not supported. Instead, subpackage "
"tests install their runtime requirements---but not the run requirements "
"for the top-level package---and the test-time requirements of the top-"
"level package."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1172
msgid ""
"EXAMPLE: In this example, the test for ``subpackage-name`` installs "
"``some-test-dep`` and ``subpackage-run-req``, but not ``some-top-level-"
"run-req``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1195
msgid "Output type"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1197
msgid ""
"Conda-build supports creating packages other than conda packages. "
"Currently that support includes only wheels, RPMs, .deb files, but others"
" may come as demand appears. If type is not specified, the default value "
"is ``conda``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1212
msgid ""
"Currently you must include the wheel package in your top-level "
"requirements/build section in order to build wheels."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1215
msgid ""
"When specifying type, the name field is optional, and it defaults to the "
"package/name field for the top-level recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1227
msgid ""
"Conda build currently knows how to test only conda packages. Conda build "
"does support using Twine to upload packages to PyPI. See the conda build "
"help output for the list of arguments accepted that will be passed "
"through to Twine."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1232
msgid "NOTE: You must use pip to install Twine in order for this to work."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1239
msgid "About section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1241
msgid ""
"Specifies identifying information about the package. The information "
"displays in the Anaconda.org channel."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1254
msgid "License file"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1256
msgid ""
"Add a file containing the software license to the package metadata.  Many"
" licenses require the license statement to be distributed with the "
"package. The filename is relative to the source directory."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1268
msgid "App section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1270
msgid ""
"If the app section is present, the package is an app, meaning that it "
"appears in the Anaconda Launcher."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1275
msgid "Entry point"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1277
msgid "The command that is called to launch the app."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1286
msgid "Icon file"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1288
msgid "The icon file contained in the recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1297
msgid "Summary"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1299
msgid "Summary of the package used in the launcher."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1308
msgid "Own environment"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1310
msgid ""
"If ``True``, installing the app through the launcher installs into its "
"own environment. The default is ``False``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1320
msgid "Extra section"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1322
msgid ""
"A schema-free area for storing non-conda-specific metadata in standard "
"YAML form."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1325
msgid "EXAMPLE: To store recipe maintainer information:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1337
msgid "Templating with Jinja"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1339
msgid "Conda build supports Jinja templating in the ``meta.yaml`` file."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1341
msgid ""
"EXAMPLE: The following ``meta.yaml`` would work with the GIT values "
"defined for git repositores. The recipe is included at the base directory"
" of the git repository, so the git_url is ``../``:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1362
msgid ""
"Conda build checks if the jinja2 variables that you use are defined and "
"produces a clear error if it is not."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1365
msgid ""
"You can also use a different syntax for these environment variables that "
"allows default values to be set, although it is somewhat more verbose."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1369
msgid ""
"EXAMPLE: A version of the previous example using the syntax that allows "
"defaults:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1388
msgid ""
"One further possibility using templating is obtaining data from your "
"downloaded source code."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1391
msgid ""
"EXAMPLE: To process a project's ``setup.py`` and obtain the version and "
"other metadata:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1407
msgid ""
"These functions are completely compatible with any other variables such "
"as git and mercurial."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1410
msgid ""
"Extending this arbitrarily to other functions requires that functions be "
"predefined before jinja processing, which in practice means changing the "
"conda build source code. See the `conda build issue tracker "
"<https://github.com/conda/conda-build/issues>`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1416
msgid ""
"For more information, see the `Jinja2 template documentation "
"<http://jinja.pocoo.org/docs/dev/templates/>`_ and :doc:`the list of "
"available environment variables <environment-variables>`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1421
msgid ""
"Jinja templates are evaluated during the build process. To retrieve a "
"fully rendered ``meta.yaml`` use the :doc:`../../../commands/build/conda-"
"render`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1428
msgid "Conda-build specific Jinja2 functions"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1430
msgid ""
"Besides the default Jinja2 functionality, additional Jinja functions are "
"available during the conda-build process: ``pin_compatible``, "
"``pin_subpackage``, ``compiler``, and ``resolved_packages``. Please see "
":ref:`extra_jinja2` for the definition of the first three functions. "
"Definition of ``resolved_packages`` is given below:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1436
msgid ""
"``resolved_packages('environment_name')``: Returns the final list of "
"packages (in the form of ``package_name version build_string``) that are "
"listed in ``requirements:host`` or ``requirements:build``. This includes "
"all packages (including the indirect dependencies) that will be installed"
" in the host or build environment. ``environment_name`` must be either "
"``host`` or ``build``. This function is useful for creating meta packages"
" that will want to pin all of their *direct* and *indirect* dependencies "
"to their exact match. For example::"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1453
msgid "might render to (depending on package dependencies and the platform)::"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1471
msgid "Here, output of ``resolved_packages`` was::"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1480
msgid "Preprocessing selectors"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1482
msgid ""
"You can add selectors to any line, which are used as part of a "
"preprocessing stage. Before the ``meta.yaml`` file is read, each selector"
" is evaluated, and if it is ``False``, the line that it is on is removed."
" A selector has the form ``# [<selector>]`` at the end of a line."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1494
msgid "NOTE: Preprocessing selectors are evaluated after Jinja templates."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1496
msgid ""
"A selector is a valid Python statement that is executed. The following "
"variables are defined. Unless otherwise stated, the variables are "
"booleans."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1503
msgid "x86"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1504
msgid ""
"True if the system architecture is x86, both 32-bit and 64-bit, for Intel"
" or AMD chips."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1506
msgid "x86_64"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1507
msgid ""
"True if the system architecture is x86_64, which is 64-bit, for Intel or "
"AMD chips."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1509
msgid "linux"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1510
msgid "True if the platform is Linux."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1511
msgid "linux32"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1512
msgid "True if the platform is Linux and the Python architecture is 32-bit."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1514
msgid "linux64"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1515
msgid "True if the platform is Linux and the Python architecture is 64-bit."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1517
msgid "armv6l"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1518
msgid "True if the platform is Linux and the Python architecture is armv6l."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1520
msgid "armv7l"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1521
msgid "True if the platform is Linux and the Python architecture is armv7l."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1523
msgid "ppc64le"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1524
msgid "True if the platform is Linux and the Python architecture is ppc64le."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1526
msgid "osx"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1527
msgid "True if the platform is macOS."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1528
msgid "unix"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1529
msgid "True if the platform is either macOS or Linux."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1530
msgid "win"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1531
msgid "True if the platform is Windows."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1532
msgid "win32"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1533
msgid "True if the platform is Windows and the Python architecture is 32-bit."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1535
msgid "win64"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1536
msgid "True if the platform is Windows and the Python architecture is 64-bit."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1538
msgid "py"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1539
msgid ""
"The Python version as an int, such as ``27`` or ``36``. See the CONDA_PY "
":ref:`environment variable <build-envs>`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1541
msgid "py3k"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1542
msgid "True if the Python major version is 3."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1543
msgid "py2k"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1544
msgid "True if the Python major version is 2."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1545
msgid "py27"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1546
msgid "True if the Python version is 2.7."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1547
msgid "py34"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1548
msgid "True if the Python version is 3.4."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1549
msgid "py35"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1550
msgid "True if the Python version is 3.5."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1551
msgid "py36"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1552
msgid "True if the Python version is 3.6."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1553
msgid "np"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1554
msgid ""
"The NumPy version as an integer such as ``111``. See the CONDA_NPY "
":ref:`environment variable <build-envs>`."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1557
msgid ""
"Because the selector is any valid Python expression, complicated logic is"
" possible:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/define-metadata.rst:1567
msgid ""
"NOTE: The selectors delete only the line that they are on, so you may "
"need to put the same selector on multiple lines:"
msgstr ""

