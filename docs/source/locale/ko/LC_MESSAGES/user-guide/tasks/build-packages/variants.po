# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Anaconda, Inc.
# This file is distributed under the same license as the Conda package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Conda  \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-18 12:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../source/user-guide/tasks/build-packages/variants.rst:2
msgid "Build Variants"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:4
msgid ""
"The nature of binary compatibility (and incompatibility) means that we "
"sometimes need to build binary packages (and any package containing "
"binaries) with several variants to support different usage environments. "
"For example, using Numpy's C API means that a package must be used with "
"the same version of Numpy at runtime that was used at build time."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:10
msgid ""
"There has been limited support for this for a long time. Including Python"
" in both build and run requirements resulted in a package with Python "
"pinned to the version of Python used at build time, and a corresponding "
"addition to the filename such as \"py27\". Similar support existed for "
"numpy with the addition of an ``x.x`` pin in the recipe after `Conda-"
"build PR 573 <https://github.com/conda/conda-build/pull/573>`_ was "
"merged. Before conda-build version 3.0 there were also many longstanding "
"proposals for general support (`Conda-build issue 1142 "
"<https://github.com/conda/conda-build/issues/1142>`_)."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:20
msgid ""
"As of conda-build 3.0, a new configuration scheme has been added, dubbed "
"\"variants.\" Conceptually, this decouples pinning values from recipes, "
"replacing them with Jinja2 template variables. It adds support for the "
"notion of \"compatible\" pinnings to be integrated with ABI compatibility"
" databases, such as `ABI Laboratory <https://abi-laboratory.pro/>`_. Note"
" that the concept of \"compatible\" pinnings is currently still under "
"heavy development."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:27
msgid ""
"Variant input is ultimately a dictionary. These dictionaries are mostly "
"very flat. Keys are made directly available in Jinja2 templates. As a "
"result, keys in the dictionary (and in files read into dictionaries) must"
" be valid jinja2 variable names (no ``-`` characters allowed). This "
"example builds python 2.7 and 3.5 packages in one build command:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:33
msgid "conda_build_config.yaml like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:42
msgid "meta.yaml contents like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:57
msgid ""
"The command to build recipes is unchanged relative to earlier conda-build"
" versions. For example, with our shell in the same folder as meta.yaml "
"and conda_build_config.yaml, we just call the ``conda build .`` command."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:63
msgid "General pinning examples"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:65
msgid ""
"There are a few characteristic use cases for pinning.  Please consider "
"this a map for the content below."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:68
msgid ""
"Shared library providing a binary interface. All uses of this library use"
" the binary interface. It is convenient to apply the same pin to all of "
"your builds. Example: boost"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:72
msgid "conda_build_config.yaml in your HOME folder:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:82
#: ../../source/user-guide/tasks/build-packages/variants.rst:122
#: ../../source/user-guide/tasks/build-packages/variants.rst:563
#: ../../source/user-guide/tasks/build-packages/variants.rst:581
#: ../../source/user-guide/tasks/build-packages/variants.rst:824
#: ../../source/user-guide/tasks/build-packages/variants.rst:870
#: ../../source/user-guide/tasks/build-packages/variants.rst:891
#: ../../source/user-guide/tasks/build-packages/variants.rst:913
#: ../../source/user-guide/tasks/build-packages/variants.rst:1065
msgid "meta.yaml:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:96
msgid "This example demonstrates several features:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:98
msgid ""
"user-wide configuration with a specifically named config file "
"(conda_build_config.yaml in your home folder). More options below in "
"`Creating conda-build variant config files`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:101
msgid ""
"building against multiple versions of a single library (set versions "
"installed at build time)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:103
msgid ""
"pinning runtime requirements to the version used at build time. More "
"information below at `Pinning at the variant level`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:105
msgid ""
"specify granularity of pinning. ``x.x`` pins major and minor version. "
"More information at `Pinning expressions`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:109
msgid ""
"Python package with externally accessible binary component. Not all uses "
"of this library use the binary interface (some only use pure Python). "
"Example: numpy"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:113
msgid "conda_build_config.yaml in your recipe folder (alongside meta.yaml):"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:138
msgid ""
"This example demonstrates a particular feature: reduction of builds when "
"pins are unnecessary. Since the example recipe above only requires the "
"Python API to numpy, we will only build the package once and the version "
"of numpy will not be pinned at runtime to match the compile-time version."
"  There's more information at `Avoiding unnecessary builds`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:144
msgid ""
"For a different package that makes use of the numpy C API, we will need "
"to actually pin numpy in this recipe (and only in this recipe, so that "
"other recipes don't unnecessarily build lots of variants).  To pin numpy,"
" you can use the variant key directly in meta.yaml:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:161
msgid ""
"For legacy compatibility, python is pinned implicitly without specifying "
"``{{ python }}`` in your recipe. This is generally intractable to extend "
"to all package names, so in general, try to get in the habit of always "
"using the jinja2 variable substitution for pinning using versions from "
"your conda_build_config.yaml file."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:167
msgid ""
"There are also more flexible ways to pin, using the `Pinning "
"expressions`_. See `Pinning at the recipe level`_ for examples."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:171
msgid ""
"One recipe splits into multiple packages, and package dependencies need "
"to be dynamically pinned among one another. Example: "
"GCC/libgcc/libstdc++/gfortran/etc."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:175
msgid ""
"The dynamic pinning is the tricky part. Conda-build provides new ways to "
"refer to other subpackages within a single recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:192
msgid ""
"By referring to subpackages this way, you don't need to worry about what "
"the end version of my_awesome_subpackage will be. Update it independently"
" and just let conda build figure it out and keep things consistent. "
"There's more information below in the `Referencing subpackages`_ section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:199
msgid "Transition guide"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:201
msgid ""
"Let's say we have a set of recipes that currently builds a C library, as "
"well as python and R bindings to that C library. xgboost, a recent "
"machine learning library, is one such example. Under conda-build 2.0 and "
"earlier, you needed to have three recipes - one for each component. Let's"
" go over some simplified meta.yaml files.  First, the C library:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:214
msgid "Next, the python bindings:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:246
msgid ""
"To build these, you'd need several conda-build commands, or a tool like "
"conda-build-all to build out the various python versions. With conda-"
"build 3.0 and split packages from conda-build 2.1, we can simplify this "
"to one coherent recipe that also includes the matrix of all desired "
"python and R builds."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:251
msgid "First, the meta.yaml file:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:271
msgid "Next, the conda_build_config.yaml file, specifying our build matrix:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:283
msgid ""
"With this updated method, you get a complete build matrix: 6 builds "
"total. One libxgboost library, 3 python versions, and 2 R versions. "
"Additionally, the python and R packages will have exact pins to the "
"libxgboost package that was built by this recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:292
msgid "Creating conda-build variant config files"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:294
msgid ""
"Variant input files are yaml files.  Search order for these files is the "
"following:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:296
msgid "a file named ``conda_build_config.yaml`` in the user's HOME folder"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:297
msgid ""
"an arbitrarily named file specified as the value for the "
"``conda_build/config_file`` key in your .condarc file"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:299
msgid ""
"a file named ``conda_build_config.yaml`` in the same folder as "
"``meta.yaml`` with your recipe"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:301
msgid ""
"Any additional files specified on the command line with the ``--variant-"
"config-files`` or ``-m`` command line flags, which can be passed multiple"
" times for multiple files. The ``conda build`` and ``conda render`` "
"commands accept these arguments."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:306
msgid ""
"Values in files found later in this search order will overwrite and "
"replace the values from earlier files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:309
msgid "NOTE: The key ``conda_build/config_file`` is a nested value::"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:316
msgid "Using variants with the conda-build API"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:318
msgid ""
"Ultimately, a variant is just a dictionary. This dictionary is provided "
"directly to Jinja2, and you can use any declared key from your variant "
"configuration in your Jinja2 templates. There are two ways that you can "
"feed this information into the API:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:323
msgid ""
"Pass the ``variants`` keyword argument to API functions. Currently, the "
"``build``, ``render``, ``get_output_file_path``, and ``check`` functions "
"accept this argument. ``variants`` should be a dictionary where each "
"value is a list of versions to iterate over. These are aggregated as "
"detailed in the `Aggregation of multiple variants`_ section below."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:329
msgid ""
"Set the ``variant`` member of a Config object. This is just a dictionary."
" The values for fields should be strings or lists of strings, except "
"\"extended keys\", which are documented in the `Extended keys`_ section "
"below."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:334
msgid "Again, with meta.yaml contents like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:348
msgid "You could supply a variant to build this recipe like so:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:356
msgid ""
"Note that these Jinja2 variable substitutions are not limited to version "
"numbers. You can use them anywhere, for any string value. For example, to"
" build against different MPI implementations:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:360
msgid "With meta.yaml contents like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:375
msgid ""
"You could supply a variant to build this recipe like this "
"(conda_build_config.yaml):"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:384
msgid ""
"Selectors are valid in conda_build_config.yaml, so you can have one "
"conda_build_config.yaml for multiple platforms:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:395
msgid ""
"Jinja is not allowed in conda_build_config.yaml, though. It is the source"
" of information to feed into other jinja templates, and the buck has to "
"stop somewhere."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:401
msgid "About reproducibility"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:403
msgid ""
"A critical part of any build system is ensuring that you can reproduce "
"the same output at some future point in time. This is often essential for"
" troubleshooting bugs. For example, if a package contains only binaries, "
"it is helpful to understand what source code created those binaries, and "
"thus what bugs might be present."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:409
msgid ""
"Since conda-build 2.0, conda-build has recorded its rendered meta.yaml "
"files into the ``info/recipe`` folder of each package it builds. Conda-"
"build 3.0 is no different in this regard, but the meta.yaml that is "
"recorded is a frozen set of the variables that make up the variant for "
"that build."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:414
msgid ""
"Note that package builders may disable including the recipe with the "
"``build/include_recipe`` key in meta.yaml. If the recipe is omitted from "
"the package, then the package is not reproducible without the source "
"recipe."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:420
msgid "Special variant keys"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:422
msgid ""
"There are some special keys that behave differently and can be more "
"nested:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:424
msgid ""
"``zip_keys``: a list of strings or a list of lists of strings. Strings "
"are keys in variant. These couple groups of keys, so that particular keys"
" are paired, rather than forming a matrix. This is useful, for example, "
"to couple vc version to python version on Windows. More info below in the"
" `Coupling keys`_ section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:429
msgid ""
"``pin_run_as_build``: should be a dictionary. Keys are package names. "
"Values are \"pinning expressions\" - explained in more detail in "
"`Customizing compatibility`_. This is a generalization of the ``numpy "
"x.x`` spec, so that you can pin your packages dynamically based on the "
"versions used at build time."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:434
msgid ""
"``extend_keys``: specifies keys that should be aggregated, and not "
"replaced, by later variants. These are detailed below in the `Extended "
"keys`_ section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:437
msgid ""
"``ignore_version``: list of package names whose versions should be "
"excluded from meta.yaml's requirements/build when computing hash. "
"Described further in `Avoiding unnecessary builds`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:443
msgid "Coupling keys"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:445
msgid ""
"Sometimes particular versions need to be tied to other versions. For "
"example, on Windows, we generally follow the upstream Python.org "
"association of Visual Studio compiler version with Python version. Python"
" 2.7 is always compiled with Visual Studio 2008 (also known as MSVC 9). "
"We don't want a conda_build_config.yaml like the following to create a "
"matrix of python/MSVC versions:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:461
msgid ""
"Instead, we want 2.7 to be associated with 9, and 3.5 to be associated "
"with 14. The ``zip_keys`` key in conda_build_config.yaml is the way to "
"achieve this:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:476
msgid "You can also have nested lists to achieve multiple groups of ``zip_keys``:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:488
msgid "The rules for ``zip_keys`` are:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:490
msgid ""
"Every list in a group must be the same length. This is because without "
"equal length, there is no way to associate earlier elements from the "
"shorter list with later elements in the longer list. For example, this is"
" invalid, and will raise an error:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:506
msgid ""
"``zip_keys`` must be either a list of strings, or a list of lists of "
"strings. You can't mix them.  For example, this is an error:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:518
msgid ""
"Rule #1 raises an interesting use case: How does one combine CLI flags "
"like --python with ``zip_keys``? Such a CLI flag will change the variant "
"so that it has only a single entry, but it will not change the ``vc`` "
"entry in the variant configuration. We'll end up with mismatched list "
"lengths, and an error. To overcome this, you should instead write a very "
"simple YAML file with all involved keys. Let's call it ``python27.yaml``,"
" to reflect its intent:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:532
msgid "Provide this file as a command-line argument:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:538
msgid ""
"You can also specify variants in JSON notation from the CLI as detailed "
"in the :ref:`CLI_vars` section. For example:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:547
msgid "Avoiding unnecessary builds"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:549
msgid ""
"To avoid building variants of packages where pinning does not require "
"having different builds, you can use the ``ignore_version`` key in your "
"variant. Then all variants are evaluated, but if any hashes are the same,"
" then they are considered duplicates, and are deduplicated. By omitting "
"some packages from the build dependencies, we can avoid creating "
"unnecessarily specific hashes, and allow this deduplication."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:556
msgid ""
"For example, let's consider a package that uses numpy in both run and "
"build requirements, and a variant that includes two numpy versions:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:573
msgid ""
"Here, the variant says that we'll have two builds - one for each numpy "
"version. However, since this recipe does not pin numpy's run requirement "
"(because it doesn't utilize numpy's C API), it is unnecessary to build it"
" against both numpy 1.10 and 1.11."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:578
msgid ""
"The rendered form of this recipe, with conda-build ignoring numpy's value"
" in the recipe, is going to be just one build, that looks like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:591
msgid ""
"``ignore_version`` is an empty list by default. The actual build "
"performed is probably done with the last 'numpy' list element in the "
"variant, but that's an implementation detail that you should not depend "
"on. The order is considered unspecified behavior, because the output "
"should be independent of the input versions. If the output is not "
"independent of input versions, don't use this key!"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:598
msgid ""
"Any pinning done in the run requirements will affect the hash, and thus "
"builds will be done for each variant in the matrix. Any package that "
"sometimes is used for its compiled interface and sometimes used for only "
"its python interface may benefit from careful use of ``ignore_version`` "
"in the latter case."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:603
msgid ""
"Note: ``pin_run_as_build`` is kind of the opposite of ``ignore_version``."
" Where they conflict, ``pin_run_as_build`` takes priority."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:610
msgid "CONDA_* variables and command line arguments to conda-build"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:612
msgid ""
"To ensure consistency with existing users of conda-build, environment "
"variables such as CONDA_PY behave as they always have, and they overwrite"
" all variants set in files or passed to the API."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:616
msgid "The full list of respected environment variables are:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:618
msgid "CONDA_PY"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:619
msgid "CONDA_NPY"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:620
msgid "CONDA_R"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:621
msgid "CONDA_PERL"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:622
msgid "CONDA_LUA"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:624
msgid ""
"CLI flags are also still available. These are sticking around for their "
"usefulness in one-off jobs."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:627
msgid "--python"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:628
msgid "--numpy"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:629
msgid "--R"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:630
msgid "--perl"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:631
msgid "--lua"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:633
msgid ""
"In addition to these traditional options, there's one new flag to specify"
" variants: ``--variants``. This flag accepts a string of JSON-formatted "
"text. For example:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:643
msgid "Aggregation of multiple variants"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:645
msgid ""
"The matrix of all variants is first consolidated from several dicts of "
"lists into a single dict of lists, and then transformed in a list of "
"dicts (using the Cartesian product of lists), where each value is a "
"single string from the list of potential values."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:650
msgid "For example, general input for ``variants`` could be something like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:658
msgid ""
"Here, let's say ``b`` is found after ``a``, and thus has priority over "
"``a``. Merging these two variants yields:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:665
msgid ""
"``b``'s values for ``python`` have overwritten ``a``'s. From here, we "
"compute the Cartesian product of all input variables. The end result is a"
" collection of dicts, each with a string for each value. Output would be "
"something like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:673
msgid ""
"conda-build would loop over these variants where appropriate, such as "
"when building, outputting package output names, and so on."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:676
msgid ""
"If ``numpy`` had had two values instead of one, we'd end up with *four* "
"output variants: 2 variants for ``python``, *times* two variants for "
"``numpy``:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:686
msgid "Bootstrapping pins based on an existing environment"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:688
msgid ""
"To establish your initial variant, you may point at an existing conda "
"environment. Conda-build will examine the contents of that environment "
"and pin to the exact requirements that make up that environment."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:696
msgid ""
"You may specify either environment name or filesystem path to the "
"environment. Note that specifying environment name does mean depending on"
" conda's environment lookup."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:702
msgid "Extended keys"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:704
msgid ""
"These are not looped over to establish the build matrix. Rather, they are"
" aggregated from all input variants, and each derived variant shares the "
"whole set. These are used internally for tracking which requirements "
"should be pinned, for example, with the ``pin_run_as_build`` key. You can"
" add your own extended keys by passing in values for the ``extend_keys`` "
"key for any variant."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:710
msgid ""
"For example, if you wanted to collect some aggregate trait from multiple "
"conda_build_config.yaml files, you could do something like this:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:713
msgid "HOME/conda_build_config.yaml:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:722
#: ../../source/user-guide/tasks/build-packages/variants.rst:742
msgid "recipe/conda_build_config.yaml:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:731
msgid ""
"Note that *both* of the conda_build_config.yaml files need to list the "
"trait as an ``extend_keys`` entry.  If you list it in only one of them, "
"an error will be raised, to avoid confusion with one "
"conda_build_config.yaml file that would add entries to the build matrix, "
"and another which would not. For example, this should raise an error:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:751
msgid ""
"When our two proper yaml config files are combined, ordinarily the "
"recipe-local variant would overwrite the user-wide variant, yielding "
"``{'some_trait': 'pony'}``. However, with the extend_keys entry, we end "
"up with what we've always wanted: a dog *and* pony show: ``{'some_trait':"
" ['dog', 'pony'])}``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:756
msgid ""
"Again, mostly an internal implementation detail - unless you find a use "
"for it. Internally, it is used to aggregate the ``pin_run_as_build`` and "
"``ignore_version`` entries from any of your conda_build_config.yaml "
"files."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:763
msgid "Customizing compatibility"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:768
msgid "Pinning expressions"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:770
msgid ""
"Pinning expressions are the syntax used to specify how many parts of the "
"version to pin. They are by convention strings containing ``x`` "
"characters separated by ``.``. The number of version parts to pin is "
"simply the number of things that are separated by ``.``. For example, "
"``\"x.x\"`` pins major and minor version. ``\"x\"`` pins only major "
"version."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:776
msgid ""
"Wherever pinning expressions are accepted, you can customize both lower "
"and upper bounds."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:784
msgid ""
"Note that the final pin may be more specific than your initial spec. "
"Here, the spec is 1.11, but the produced pin could be 1.11.2, the exact "
"version of numpy that was used at build time."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:795
msgid "Pinning at the variant level"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:797
msgid ""
"Some packages, such as boost, *always* need to be pinned at runtime to "
"the version that was present at build time. For these cases where the "
"need for pinning is consistent, pinning at the variant level is a good "
"option. Conda-build will automatically pin run requirements to the "
"versions present in the build environment when the following conditions "
"are met:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:803
msgid ""
"The dependency is listed in the requirements/build section. It can be "
"pinned, but does not need to be."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:805
msgid ""
"The dependency is listed by name (no pinning) in the requirements/run "
"section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:806
msgid ""
"The ``pin_run_as_build`` key in the variant has a value that is a "
"dictionary, containing a key that matches the dependency name listed in "
"the run requirements. The value should be a dictionary with up to 4 keys:"
" ``min_pin``, ``max_pin``, ``lower_bound``, ``upper_bound``. The first "
"two are pinning expressions. The latter two are version numbers, "
"overriding detection of current version."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:813
msgid "An example variant/recipe is shown here:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:815
msgid "conda_build_config.yaml:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:834
msgid ""
"The result here is that the runtime boost dependency will be pinned to "
"``>=(current boost 1.63.x version),<1.64``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:837
msgid ""
"More details on the ``pin_run_as_build`` function is below in the "
":ref:`extra_jinja2` section."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:840
msgid ""
"Note that there are some packages that you should not use "
"``pin_run_as_build`` for. Packages that don't *always* need to be pinned "
"should be pinned on a per-recipe basis (described in the next section). "
"Numpy is an interesting example here. It actually would not make a good "
"case for pinning at the variant level. Because you only need this kind of"
" pinning for recipes that use Numpy's C API, it would actually be better "
"not to pin numpy with ``pin_run_as_build``. Pinning it is over-"
"constraining your requirements unnecessarily when you are not using "
"Numpy's C API. Instead, we should customize it for each recipe that uses "
"numpy.  See also the `Avoiding unnecessary builds`_ section above."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:852
msgid "Pinning at the recipe level"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:854
msgid ""
"Pinning at the recipe level overrides pinning at the variant level, "
"because run dependencies that have pinning values in meta.yaml (even as "
"jinja variables) are ignored by the logic handling ``pin_run_as_build``. "
"We expect that pinning at the recipe level will be used when some "
"recipe's pinning is unusually stringent (or loose) relative to some "
"standard pinning from the variant level."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:860
msgid ""
"By default, with the ``pin_compatible('package_name')`` function, conda-"
"build pins to your current version and less than the next major version. "
"For projects that don't follow the philosophy of semantic versioning, you"
" might want to restrict things more tightly. To do so, you can pass one "
"of two arguments to the pin_compatible function."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:881
msgid "This would yield a pinning of ``>=1.11.2,<1.12``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:883
msgid ""
"The syntax for the ``min_pin`` and ``max_pin`` is a string pinning "
"expression. Each can be passed independently of the other. An example of "
"specifying both:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:902
msgid "This would yield a pinning of ``>=1.11,<1.12``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:905
msgid ""
"You can also pass the minimum or maximum version directly. These "
"arguments supersede the ``min_pin`` and ``max_pin`` arguments and are "
"thus mutually exclusive."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:924
msgid "This would yield a pinning of ``>=1.10,<3.0``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:928
msgid "Appending to recipes"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:930
msgid ""
"As of conda-build 3.0, you can add a file named ``recipe_append.yaml`` in"
" the same folder as your ``meta.yaml`` file. This file is considered to "
"follow the same rules as meta.yaml, except that selectors and Jinja2 "
"templates are not evaluated. Evaluation of selectors and Jinja2 templates"
" will likely be added in future development."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:936
msgid ""
"Any contents in ``recipe_append.yaml`` will add to the contents of "
"meta.yaml. List values will be extended, and string values will be "
"concatenated. The proposed use case for this is to tweak/extend central "
"recipes, such as those from conda-forge, with additional requirements "
"while minimizing the actual changes to recipe files, so as to avoid merge"
" conflicts and source code divergence."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:945
msgid "Partially clobbering recipes"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:947
msgid ""
"As of conda-build 3.0, you can add a file named ``recipe_clobber.yaml`` "
"in the same folder as your ``meta.yaml`` file. This file is considered to"
" follow the same rules as meta.yaml, except that selectors and Jinja2 "
"templates are not evaluated. Evaluation of selectors and Jinja2 templates"
" will likely be added in future development."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:953
msgid ""
"Any contents in ``recipe_clobber.yaml`` will replace the contents of "
"meta.yaml. This can be useful, for example, for replacing the source URL "
"without copying the rest of the recipe into a fork."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:959
msgid "Differentiating packages built with different variants"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:961
msgid ""
"With only a few things supported, we could just add things to the "
"filename, such as py27 for python, or np111 for numpy. Variants are meant"
" to support the general case, and in the general case this is no longer "
"an option. Instead, used variant keys and values are hashed using the "
"sha1 algorithm, and that hash is a unique identifier. The information "
"that went into the hash is stored with the package, in a file at "
"``info/hash_input.json``. Packages only have a hash when there are any "
"\"used\" variables beyond the ones that are already accounted for in the "
"build string (py, np, etc). The takeaway message is that hashes will "
"appear when binary compatibility matters, but not when it doesn't."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:971
msgid ""
"Currently, only the first 7 characters of the hash are stored. Output "
"package names will keep the pyXY and npXYY, but may have added the "
"7-character hash. Your package names will look like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:975
msgid "``my-package-1.0-py27h3142afe_0.tar.bz2``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:977
msgid ""
"As of conda-build 3.1.0, this hashing scheme has been simplified. A hash "
"will be added if all of these are true for any dependency:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:980
msgid "package is an explicit dependency in build, host, or run deps"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:981
msgid ""
"package has a matching entry in conda_build_config.yaml which is a pin to"
" a specific version, not a lower bound"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:983
msgid "that package is not ignored by ignore_version"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:985
msgid "OR"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:987
msgid "package uses {{ compiler() }} jinja2 function"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:989
msgid ""
"Since conflicts only need to be prevented within one version of a "
"package, we think this will be adequate. If you run into hash collisions "
"with this limited subspace, please file an issue on the `conda-build "
"issue tracker <https://github.com/conda/conda-build/issues>`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:994
msgid ""
"There is a CLI tool that just pretty-prints this json file for easy "
"viewing:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1000
msgid "This produces output such as:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1011
msgid "Extra Jinja2 functions"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1013
msgid ""
"Two especially common operations when dealing with these API and ABI "
"incompatibilities are ways of specifying such compatibility, and of "
"explicitly expressing the compiler to be used. Three new Jinja2 functions"
" are available when evaluating ``meta.yaml`` templates:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1018
msgid ""
"``pin_compatible('package_name', min_pin='x.x.x.x.x.x', max_pin='x', "
"lower_bound=None, upper_bound=None)``: To be used as pin in run and/or "
"test requirements. Takes package name argument. Looks up compatibility of"
" named package installed in the build environment, and writes compatible "
"range pin for run and/or test requirements. Defaults to a semver-based "
"assumption: ``package_name >=(current version),<(next major version)``. "
"Pass ``min_pin`` or ``max_pin`` a `Pinning expressions`_ . This will be "
"enhanced as time goes on with information from `ABI Laboratory <https"
"://abi-laboratory.pro/>`_."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1027
msgid ""
"``pin_subpackage('package_name', min_pin='x.x.x.x.x.x', max_pin='x', "
"exact=False)``: To be used as pin in run and/or test requirements. Takes "
"package name argument. Used to refer to particular versions of "
"subpackages built by parent recipe as dependencies elsewhere in that "
"recipe. Can use either pinning expressions, or exact (including build "
"string)."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1033
msgid ""
"``compiler('language')``: To be used in build requirements most commonly."
" Run or test as necessary. Takes language name argument. This is "
"shorthand to facilitate cross compiler usage. This Jinja2 function ties "
"together two variant variables, ``{language}_compiler`` and "
"``target_platform``, and outputs a single compiler package name. For "
"example, this could be used to compile outputs targeting x86_64 and arm "
"in one recipe, with a variant."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1040
msgid ""
"There are default \"native\" compilers that are used when no compiler is "
"specified in any variant. These are defined in `conda-build's "
"jinja_context.py file <https://github.com/conda/conda-"
"build/blob/master/conda_build/jinja_context.py>`_. Most of the time, "
"users will not need to provide compilers in their variants - just leave "
"them empty, and conda-build will use the defaults appropriate for your "
"system."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1051
msgid "Referencing subpackages"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1053
msgid ""
"Conda-build 2.1 brought in the ability to build multiple output packages "
"from a single recipe. This is useful in cases where you have a big build "
"that outputs a lot of things at once, but those things really belong in "
"their own packages. For example, building gcc outputs not only gcc, but "
"also gfortran, g++, and runtime libraries for gcc, gfotran and g++. Each "
"of those should be their own package to make things as clean as possible."
" Unfortunately, if there are separate recipes to repack the different "
"pieces from a larger whole package, it can be hard to keep them in sync. "
"That's where variants come in. Variants, and more specifically the "
"``pin_subpackage(name)`` function, give you a way to refer to the "
"subpackage with control over how tightly the subpackage version "
"relationship should be in relation to other subpackages or the parent "
"package."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1091
msgid ""
"Here, the parent package will have the following different runtime "
"dependencies:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1093
msgid ""
"subpackage_1 >=1.0.0,<2 (default uses ``min_pin='x.x.x.x.x.x``, "
"``max_pin='x'``, pins to major version with default >= current version "
"lower bound)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1096
msgid "subpackage_2 >=2.0.0,<2.1 (more stringent upper bound)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1097
msgid ""
"subpackage_3 >=3.0,<3.1 (less stringent lower bound, more stringent upper"
" bound)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1098
msgid "subpackage_4 4.0.0 h81241af (exact pinning - version plus build string)"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1102
msgid "Compiler packages"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1104
msgid ""
"On Mac and Linux, we can and do ship gcc packages.  These will become "
"even more powerful with variants, since you can specify versions of your "
"compiler much more explicitly, and build against different versions, or "
"with different flags set in the compiler package's activate.d scripts. On"
" Windows, rather than providing the actual compilers in packages, we "
"still use the compilers that are installed on the system. The analogous "
"compiler packages on Windows run any compiler activation scripts and set "
"compiler flags instead of actually installing anything."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1113
msgid ""
"Over time, conda-build will require that all packages explicitly list "
"their compiler requirements this way. This is to both simplify conda-"
"build and improve the tracking of metadata associated with compilers - "
"localize it to compiler packages, even if those packages are doing "
"nothing more than activating an already-installed compiler, such as "
"Visual Studio."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1119
msgid ""
"Note also the ``run_exports`` key in meta.yaml. This is useful for "
"compiler recipes to impose runtime constraints based on the versions of "
"subpackages created by the compiler recipe. For more information, see the"
" :ref:`run_exports` section of the meta.yaml docs. Compiler packages "
"provided by Anaconda use the run_exports key extensively. For example, "
"recipes that include the ``gcc_linux-cos5-x86_64`` package as a build "
"time dependency (either directly, or through a ``{{ compilers('c') }}`` "
"jinja2 function) will automatically have a compatible libgcc runtime "
"dependency added."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1130
msgid "Compiler versions"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1132
msgid ""
"Usually the newest compilers are the best compilers, but in some special "
"cases you'll need to use older compilers."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1135
msgid ""
"For example, NVIDIA's CUDA libraries only support compilers that they "
"have rigorously tested. Often the latest gcc compiler is not supported "
"for use with CUDA. If your recipe needs to use CUDA, you'll need to use "
"an older version of GCC."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1140
msgid ""
"There are special keys associated with the compilers. The key name of "
"each special key is the compiler key name plus ``_version``."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1143
msgid ""
"For example, if your compiler key is ``c_compiler``, the version key "
"associated with it is ``c_compiler_version``. If you have a recipe for "
"Tensorflow with GPU support, put a conda_build_config.yaml file alongside"
" meta.yaml, with contents like:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1156
msgid ""
"Specify selectors so that this extra version information is not also "
"applied to Windows and Mac. Those platforms have totally different "
"compilers and could have their own versions if necessary."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1160
msgid ""
"It is not necessary to specify ``c_compiler`` or ``cxx_compiler``, "
"because the default value (``gcc`` on linux) will be used. It is "
"necessary to specify both ``c`` and ``cxx`` versions, even if they are "
"the same, because they are treated independently."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1165
msgid ""
"By placing this file in the recipe, it will apply only to this recipe. "
"All other recipes will default to the latest compiler."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1168
msgid ""
"NOTE: The version number you specify here must exist as a package in your"
" currently configured channels."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1173
msgid "Cross-compiling"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1175
msgid ""
"The compiler jinja2 function is written to support cross-compilers. This "
"depends on setting at least two variant keys: ``(language)_compiler`` and"
" ``target_platform``. The target platform is appended to the value of "
"``(language)_compiler`` with the ``_`` character. This leads to package "
"names like ``g++_linux-aarch64``. We recommend a convention for naming "
"your compiler packages as: ``<compiler name>_<target_platform>``"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1182
msgid "Using a cross-compiler in a recipe would look like the following:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1188
msgid "and a meta.yaml file:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1201
msgid ""
"This assumes that you have created two compiler packages named ``g"
"++_linux-cos5-x86_64`` and ``g++_linux-aarch64`` - all conda-build is "
"providing you with is a way to loop over appropriately named cross-"
"compiler toolchains."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1208
msgid "Self-consistent package ecosystems"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1210
msgid ""
"The compiler function is also how you could support a non-standard Visual"
" Studio version, such as using VS 2015 to compile Python 2.7 and packages"
" for Python 2.7. To accomplish this, you need to add the ``{{ "
"compiler('<language>') }}`` to each recipe that will make up the system."
"  Environment consistency is maintained through dependencies - thus it is"
" useful to have the runtime be a versioned package, with only one version"
" being able to be installed at a time. For example, the ``vc`` package, "
"originally created by Conda-Forge, is a versioned package (only one "
"version can be installed at a time), and it installs the correct runtime "
"package. When the compiler package imposes such a runtime dependency, "
"then the resultant ecosystem is self-consistent."
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1221
msgid ""
"Given these guidelines, consider a system of recipes using a variant like"
" this:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1227
msgid "The recipes include a compiler meta.yaml like this:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1238
msgid "They also include some compiler-using meta.yaml contents like this:"
msgstr ""

#: ../../source/user-guide/tasks/build-packages/variants.rst:1253
msgid ""
"These recipes will create a system of packages that are all built with "
"the VS 2015 compiler, and which have the vc package matched at version "
"14, rather than whatever default is associated with the python version."
msgstr ""

